//
//   Copyright 2014 Pixar
//
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//
//   You may obtain a copy of the Apache License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//

#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>

struct MatchPathSeparator {
    bool operator()(char ch) const {
        return ch == '\\' || ch == '/';
    }
};

std::string basename(std::string const &pathname) {
  return std::string(std::find_if( pathname.rbegin(), pathname.rend(),
                                   MatchPathSeparator()).base(),
                     pathname.end());
}

int main(int argc, char **argv) {
#define MAX_COUNTER 40

    if (argc != 3) {
        std::cerr << "Usage: quoter input-file output-file" << std::endl;
        return 1;
    }

    std::ifstream input;
    input.open(argv[1]);
    if (not input.is_open()) {
        std::cerr << "Can not read from: " << argv[1] << std::endl;
        return 1;
    }

    std::ofstream output;
    output.open(argv[2]);
    if (not output.is_open()) {
        std::cerr << "Can not write to: " << argv[2] << std::endl;
        return 1;
    }

    std::string input_basename = basename(argv[1]);
    for (int i = 0; i < (int) input_basename.size(); ++i) {
        if (input_basename[i] == '.') {
            input_basename[i] = '_';
        }
    }

    std::string file((std::istreambuf_iterator<char>(input)),
                      std::istreambuf_iterator<char>());

    output << "/* Generated by datatocpp tool */" << std::endl;
    output << "int datatoc_" << input_basename << "_size = " << file.size() << ";" << std::endl;
    output << "unsigned char datatoc_" << input_basename << "[] = {" << std::endl << "  ";
    for (int i = 0; i < (int) file.size(); ++i) {
        unsigned char ch = (unsigned char)file[i];
        output << (int) ch;
        if (i != (int) file.size() - 1) {
            output << ", ";
        }
    }
    output << std::endl << "};" << std::endl;

    return 0;

#undef MAX_COUNTER
}
